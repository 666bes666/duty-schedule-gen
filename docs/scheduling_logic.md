# Логика планирования расписания

## Приоритеты ограничений

1. **Непрерывное покрытие** — три смены (утро, вечер, ночь) каждый день
2. **Городские ограничения** — ночь только для Хабаровска
3. **Ограничения отдыха** — после вечера нельзя утро/рабочий день (недостаточно отдыха)
4. **Ограничения отпуска** — отпускники не назначаются на смены
5. **Ограничения равномерности** — 5/2 без выходных, не более 5 дней подряд
6. **Справедливость** — равномерное распределение смен

## Фазы построения дня

### Фаза 1: Ночная смена

**Кто участвует:** Только хабаровские дежурные сотрудники.

**Условия доступности:**
- Не в отпуске
- Не 5/2 в выходной день
- Не превышен лимит 5 рабочих дней подряд

> **Примечание:** ночная смена 00:00–08:00 МСК = 07:00–15:00 по хабаровскому времени. После неё достаточно времени для отдыха (16+ часов), поэтому принудительный выходной на следующий день **не** применяется.

**Выбор:** Сортировка по числу ночных смен (ascending), случайный порядок при равенстве.

**Количество:** Примерно половина от доступных хабаровских сотрудников (минимум 1).

### Фаза 2: Утренняя и вечерняя смены

**Кто участвует:** Московские дежурные сотрудники.

**Условия доступности (общие):**
- Не в отпуске
- Не после ночной смены
- Не 5/2 в выходной день
- Не превышен лимит 5 рабочих дней подряд

**Дополнительные условия:**
- Утро: `last_shift != EVENING` (нельзя утро после вечера) + `not evening_only`
- Вечер: `not morning_only`

**Выбор:** Минимум по 1 на утро и вечер. Остальные — выходной.

### Фаза 3: Рабочий день

**Кто участвует:** Не-дежурные сотрудники (`on_duty: false`).

**Правило:** Workday — в рабочие дни. Day off — в выходные/праздники или 5/2 в выходные.

### Фаза 4: Принудительное назначение

Если у московского дежурного **3 выходных подряд** и он технически доступен:
- Назначается утренняя смена (если не после вечера и не `evening_only`)
- Иначе вечерняя смена (если не `morning_only`)

Это предотвращает нарушение ограничения "не более 3 выходных подряд".

## Алгоритм отката

```python
attempts = 0
while day_idx < total_days:
    try:
        schedule_day()
        day_idx += 1
        attempts = 0
    except ScheduleError:
        attempts += 1
        if attempts > MAX_BACKTRACK_ATTEMPTS:
            raise
        # откат на 1-3 дня
        for _ in range(min(3, len(stack))):
            undo_day()
            day_idx -= 1
        # новый seed для другого выбора
        rng = Random(seed + attempts * 1000 + day_idx)
```

## Правила справедливости

### Равномерность смен

Для группы сотрудников с одинаковыми атрибутами:
```
max(смен_типа) - min(смен_типа) ≤ 1
```

Реализация: при выборе сотрудника на смену приоритет отдаётся тому, у кого меньше смен этого типа.

### Вечерние смены

Особое внимание к вечерним сменам:
```
max(вечерних) - min(вечерних) ≤ 1
```

### Равномерность по месяцу

Смены распределены по трём третям месяца. Стандартное отклонение ≤ 20% от среднего.

## Граничные случаи

### Ровно 2 хабаровских дежурных

Если оба доступны → чередование (1 работает, 1 отдыхает или оба работают).
Если один в отпуске → второй работает все ночи в эту неделю.
Если оба в отпуске в один день → ScheduleError.

### Минимальный московский штат (4 человека)

При 4 московских дежурных каждый работает примерно каждый второй-третий день.
Длинные отпуска нескольких сотрудников одновременно могут привести к ошибке.

### Много праздников подряд

5/2 сотрудники получают выходные. Гибкие — работают.
10+ праздников подряд → необходимо достаточное число гибких дежурных.

## Постобработочный pipeline

После жадной генерации выполняется 12-шаговый pipeline оптимизации:

1. **`_balance_weekend_work`** — выравнивание числа суббот/воскресений между гибкими дежурными
2. **recalc states** — пересчёт total_working после свопов
3. **`_balance_duty_shifts`** — баланс утренних/вечерних/ночных смен
4. **`_target_adjustment_pass`** (1-й) — подгонка рабочих дней под норму
5. **`_trim_long_off_blocks`** — обрезка блоков 4+ выходных подряд
6. **recalc states**
7. **`_target_adjustment_pass`** (2-й) — повторная подгонка после обрезки
8. **`_minimize_isolated_off`** — устранение изолированных выходных (extend + compensate)
9. **`_break_evening_isolated_pattern`** — своп вечерних смен для устранения паттерна "вечер → отдых → изоляция"
10. **`_minimize_isolated_off`** — повторный проход после свопов
11. **`_equalize_isolated_off`** — выравнивание изолированных между сотрудниками (разница ≤ 1 или max ≤ 2)
12. **`_minimize_isolated_off`** — финальный проход

## Детерминизм

Генерация детерминирована при одном `seed`:
1. `random.Random(seed)` — используется только этот генератор
2. Порядок обхода сотрудников фиксирован (по имени)
3. Тайбрейкинг через `rng.random()` — детерминировано
4. При откате seed изменяется предсказуемо: `seed + attempts * 1000 + day_idx`
